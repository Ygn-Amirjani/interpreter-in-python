Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> nested_stmnt
Rule 2     start -> variable_starter
Rule 3     variable_detector -> CHAR variable_detector
Rule 4     variable_detector -> INT variable_detector
Rule 5     variable_detector -> CHAR
Rule 6     variable_detector -> INT
Rule 7     assign_detector -> identifier_punctuator
Rule 8     assign_detector -> identifier_punctuator ASSIGN starting_brace
Rule 9     variable_starter -> variable_detector assign_detector SEMICOLON
Rule 10    variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON
Rule 11    variable_starter -> variable_detector SEMICOLON
Rule 12    variable_starter_chains -> variable_starter
Rule 13    variable_starter_chains -> variable_starter_chains variable_starter
Rule 14    identifier_punctuator -> IDENTIFIER
Rule 15    identifier_punctuator -> LPAREN identifier_punctuator RPAREN
Rule 16    identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter RPAREN
Rule 17    identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
Rule 18    identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER RPAREN
Rule 19    identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN
Rule 20    parameter_variable_starter -> variable_detector identifier_punctuator
Rule 21    parameter_variable_starter -> variable_detector identifier_punctuator_2
Rule 22    parameter_variable_starter -> variable_detector empty
Rule 23    starting_brace -> assigning
Rule 24    starting_brace -> LBRACE starting_brace RBRACE
Rule 25    starting_brace -> LBRACE starting_brace COMMA starting_brace RBRACE
Rule 26    starting_brace -> LBRACE starting_brace COMMA RBRACE
Rule 27    starting_brace -> LBRACE starting_brace COMMA starting_brace COMMA RBRACE
Rule 28    variable_detector_2 -> variable_detector identifier_punctuator_2
Rule 29    variable_detector_2 -> variable_detector empty
Rule 30    identifier_punctuator_2 -> LPAREN identifier_punctuator_2 RPAREN
Rule 31    identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN
Rule 32    identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
Rule 33    identifier_punctuator_2 -> identifier_punctuator_2 LPAREN empty RPAREN
Rule 34    identifier_punctuator_2 -> LPAREN parameter_variable_starter RPAREN
Rule 35    identifier_punctuator_2 -> LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
Rule 36    identifier_punctuator_2 -> LPAREN empty RPAREN
Rule 37    stmnt -> expression_2 SEMICOLON
Rule 38    stmnt -> nested_stmnt
Rule 39    stmnt -> if
Rule 40    stmnt -> loops
Rule 41    nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE
Rule 42    nested_stmnt -> LBRACE stmnt_chains RBRACE
Rule 43    nested_stmnt -> LBRACE variable_starter_chains RBRACE
Rule 44    nested_stmnt -> LBRACE RBRACE
Rule 45    stmnt_chains -> stmnt
Rule 46    stmnt_chains -> stmnt_chains stmnt
Rule 47    if -> IF LPAREN expression RPAREN stmnt
Rule 48    if -> IF LPAREN expression RPAREN stmnt ELSE stmnt
Rule 49    loops -> WHILE LPAREN expression RPAREN stmnt
Rule 50    loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
Rule 51    loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
Rule 52    expression_2 -> empty
Rule 53    expression_2 -> expression
Rule 54    expression -> assigning
Rule 55    expression -> expression COMMA assigning
Rule 56    assigning -> equal_unequal
Rule 57    assigning -> single_operand ASSIGN assigning
Rule 58    assigning -> single_operand PLUSASSIGN assigning
Rule 59    equal_unequal -> comparison
Rule 60    equal_unequal -> equal_unequal EQ comparison
Rule 61    equal_unequal -> equal_unequal NOT_EQ comparison
Rule 62    comparison -> arithmetic_precedence
Rule 63    comparison -> comparison LT arithmetic_precedence
Rule 64    comparison -> comparison GT arithmetic_precedence
Rule 65    comparison -> comparison LE arithmetic_precedence
Rule 66    comparison -> comparison GE arithmetic_precedence
Rule 67    multiply_division -> cast
Rule 68    multiply_division -> multiply_division TIMES cast
Rule 69    multiply_division -> multiply_division DIVIDE cast
Rule 70    cast -> single_operand
Rule 71    cast -> LPAREN variable_detector_2 RPAREN cast
Rule 72    arithmetic_precedence -> multiply_division
Rule 73    arithmetic_precedence -> arithmetic_precedence PLUS multiply_division
Rule 74    arithmetic_precedence -> arithmetic_precedence MINUS multiply_division
Rule 75    single_operand -> expression_combination
Rule 76    single_operand -> TIMES cast
Rule 77    single_operand -> PLUS cast
Rule 78    single_operand -> MINUS cast
Rule 79    expression_combination -> IDENTIFIER
Rule 80    expression_combination -> NUMBER
Rule 81    expression_combination -> LPAREN expression RPAREN
Rule 82    expression_combination -> expression_combination LPAREN assigning RPAREN
Rule 83    expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN
Rule 84    expression_combination -> expression_combination LPAREN RPAREN
Rule 85    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 8 57
CHAR                 : 3 5
COMMA                : 10 17 19 25 26 27 27 32 35 55 83
DIVIDE               : 69
DO                   : 51
ELSE                 : 48
EQ                   : 60
FOR                  : 50
GE                   : 66
GT                   : 64
IDENTIFIER           : 14 18 19 19 79
IF                   : 47 48
INT                  : 4 6
LBRACE               : 24 25 26 27 41 42 43 44
LE                   : 65
LPAREN               : 15 16 17 18 19 30 31 32 33 34 35 36 47 48 49 50 51 71 81 82 83 84
LT                   : 63
MINUS                : 74 78
NOT_EQ               : 61
NUMBER               : 80
PLUS                 : 73 77
PLUSASSIGN           : 58
RBRACE               : 24 25 26 27 41 42 43 44
RPAREN               : 15 16 17 18 19 30 31 32 33 34 35 36 47 48 49 50 51 71 81 82 83 84
SEMICOLON            : 9 10 11 37 50 50 51
TIMES                : 68 76
WHILE                : 49 51
error                : 

Nonterminals, with rules where they appear

arithmetic_precedence : 62 63 64 65 66 73 74
assign_detector      : 9 10 10
assigning            : 23 54 55 57 58 82 83 83
cast                 : 67 68 69 71 76 77 78
comparison           : 59 60 61 63 64 65 66
empty                : 22 29 33 36 52
equal_unequal        : 56 60 61
expression           : 47 48 49 51 53 55 81
expression_2         : 37 50 50 50
expression_combination : 75 82 83 84
identifier_punctuator : 7 8 15 16 17 18 19 20
identifier_punctuator_2 : 21 28 30 31 32 33
if                   : 39
loops                : 40
multiply_division    : 68 69 72 73 74
nested_stmnt         : 1 38
parameter_variable_starter : 16 17 17 31 32 32 34 35 35
single_operand       : 57 58 70
start                : 0
starting_brace       : 8 24 25 25 26 27 27
stmnt                : 45 46 47 48 48 49 50 51
stmnt_chains         : 41 42 46
variable_detector    : 3 4 9 10 11 20 21 22 28 29
variable_detector_2  : 71
variable_starter     : 2 12 13
variable_starter_chains : 13 41 43

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . nested_stmnt
    (2) start -> . variable_starter
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (9) variable_starter -> . variable_detector assign_detector SEMICOLON
    (10) variable_starter -> . variable_detector assign_detector COMMA assign_detector SEMICOLON
    (11) variable_starter -> . variable_detector SEMICOLON
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    LBRACE          shift and go to state 4
    CHAR            shift and go to state 6
    INT             shift and go to state 7

    start                          shift and go to state 1
    nested_stmnt                   shift and go to state 2
    variable_starter               shift and go to state 3
    variable_detector              shift and go to state 5

state 1

    (0) S' -> start .



state 2

    (1) start -> nested_stmnt .

    $end            reduce using rule 1 (start -> nested_stmnt .)


state 3

    (2) start -> variable_starter .

    $end            reduce using rule 2 (start -> variable_starter .)


state 4

    (41) nested_stmnt -> LBRACE . variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> LBRACE . stmnt_chains RBRACE
    (43) nested_stmnt -> LBRACE . variable_starter_chains RBRACE
    (44) nested_stmnt -> LBRACE . RBRACE
    (12) variable_starter_chains -> . variable_starter
    (13) variable_starter_chains -> . variable_starter_chains variable_starter
    (45) stmnt_chains -> . stmnt
    (46) stmnt_chains -> . stmnt_chains stmnt
    (9) variable_starter -> . variable_detector assign_detector SEMICOLON
    (10) variable_starter -> . variable_detector assign_detector COMMA assign_detector SEMICOLON
    (11) variable_starter -> . variable_detector SEMICOLON
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    RBRACE          shift and go to state 10
    CHAR            shift and go to state 6
    INT             shift and go to state 7
    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    variable_starter_chains        shift and go to state 8
    stmnt_chains                   shift and go to state 9
    variable_starter               shift and go to state 11
    stmnt                          shift and go to state 12
    variable_detector              shift and go to state 5
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 5

    (9) variable_starter -> variable_detector . assign_detector SEMICOLON
    (10) variable_starter -> variable_detector . assign_detector COMMA assign_detector SEMICOLON
    (11) variable_starter -> variable_detector . SEMICOLON
    (7) assign_detector -> . identifier_punctuator
    (8) assign_detector -> . identifier_punctuator ASSIGN starting_brace
    (14) identifier_punctuator -> . IDENTIFIER
    (15) identifier_punctuator -> . LPAREN identifier_punctuator RPAREN
    (16) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN

    SEMICOLON       shift and go to state 38
    IDENTIFIER      shift and go to state 40
    LPAREN          shift and go to state 41

    assign_detector                shift and go to state 37
    identifier_punctuator          shift and go to state 39

state 6

    (3) variable_detector -> CHAR . variable_detector
    (5) variable_detector -> CHAR .
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    SEMICOLON       reduce using rule 5 (variable_detector -> CHAR .)
    IDENTIFIER      reduce using rule 5 (variable_detector -> CHAR .)
    LPAREN          reduce using rule 5 (variable_detector -> CHAR .)
    RPAREN          reduce using rule 5 (variable_detector -> CHAR .)
    COMMA           reduce using rule 5 (variable_detector -> CHAR .)
    CHAR            shift and go to state 6
    INT             shift and go to state 7

    variable_detector              shift and go to state 42

state 7

    (4) variable_detector -> INT . variable_detector
    (6) variable_detector -> INT .
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    SEMICOLON       reduce using rule 6 (variable_detector -> INT .)
    IDENTIFIER      reduce using rule 6 (variable_detector -> INT .)
    LPAREN          reduce using rule 6 (variable_detector -> INT .)
    RPAREN          reduce using rule 6 (variable_detector -> INT .)
    COMMA           reduce using rule 6 (variable_detector -> INT .)
    CHAR            shift and go to state 6
    INT             shift and go to state 7

    variable_detector              shift and go to state 43

state 8

    (41) nested_stmnt -> LBRACE variable_starter_chains . stmnt_chains RBRACE
    (43) nested_stmnt -> LBRACE variable_starter_chains . RBRACE
    (13) variable_starter_chains -> variable_starter_chains . variable_starter
    (45) stmnt_chains -> . stmnt
    (46) stmnt_chains -> . stmnt_chains stmnt
    (9) variable_starter -> . variable_detector assign_detector SEMICOLON
    (10) variable_starter -> . variable_detector assign_detector COMMA assign_detector SEMICOLON
    (11) variable_starter -> . variable_detector SEMICOLON
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    RBRACE          shift and go to state 45
    CHAR            shift and go to state 6
    INT             shift and go to state 7
    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    stmnt_chains                   shift and go to state 44
    variable_starter               shift and go to state 46
    stmnt                          shift and go to state 12
    variable_detector              shift and go to state 5
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 9

    (42) nested_stmnt -> LBRACE stmnt_chains . RBRACE
    (46) stmnt_chains -> stmnt_chains . stmnt
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    RBRACE          shift and go to state 47
    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    stmnt                          shift and go to state 48
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 10

    (44) nested_stmnt -> LBRACE RBRACE .

    $end            reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    RBRACE          reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    LBRACE          reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    IF              reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    WHILE           reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    FOR             reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    DO              reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    TIMES           reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    PLUS            reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    MINUS           reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    NUMBER          reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    LPAREN          reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)
    ELSE            reduce using rule 44 (nested_stmnt -> LBRACE RBRACE .)


state 11

    (12) variable_starter_chains -> variable_starter .

    RBRACE          reduce using rule 12 (variable_starter_chains -> variable_starter .)
    CHAR            reduce using rule 12 (variable_starter_chains -> variable_starter .)
    INT             reduce using rule 12 (variable_starter_chains -> variable_starter .)
    LBRACE          reduce using rule 12 (variable_starter_chains -> variable_starter .)
    IF              reduce using rule 12 (variable_starter_chains -> variable_starter .)
    WHILE           reduce using rule 12 (variable_starter_chains -> variable_starter .)
    FOR             reduce using rule 12 (variable_starter_chains -> variable_starter .)
    DO              reduce using rule 12 (variable_starter_chains -> variable_starter .)
    TIMES           reduce using rule 12 (variable_starter_chains -> variable_starter .)
    PLUS            reduce using rule 12 (variable_starter_chains -> variable_starter .)
    MINUS           reduce using rule 12 (variable_starter_chains -> variable_starter .)
    IDENTIFIER      reduce using rule 12 (variable_starter_chains -> variable_starter .)
    NUMBER          reduce using rule 12 (variable_starter_chains -> variable_starter .)
    LPAREN          reduce using rule 12 (variable_starter_chains -> variable_starter .)
    SEMICOLON       reduce using rule 12 (variable_starter_chains -> variable_starter .)


state 12

    (45) stmnt_chains -> stmnt .

    RBRACE          reduce using rule 45 (stmnt_chains -> stmnt .)
    LBRACE          reduce using rule 45 (stmnt_chains -> stmnt .)
    IF              reduce using rule 45 (stmnt_chains -> stmnt .)
    WHILE           reduce using rule 45 (stmnt_chains -> stmnt .)
    FOR             reduce using rule 45 (stmnt_chains -> stmnt .)
    DO              reduce using rule 45 (stmnt_chains -> stmnt .)
    TIMES           reduce using rule 45 (stmnt_chains -> stmnt .)
    PLUS            reduce using rule 45 (stmnt_chains -> stmnt .)
    MINUS           reduce using rule 45 (stmnt_chains -> stmnt .)
    IDENTIFIER      reduce using rule 45 (stmnt_chains -> stmnt .)
    NUMBER          reduce using rule 45 (stmnt_chains -> stmnt .)
    LPAREN          reduce using rule 45 (stmnt_chains -> stmnt .)
    SEMICOLON       reduce using rule 45 (stmnt_chains -> stmnt .)


state 13

    (37) stmnt -> expression_2 . SEMICOLON

    SEMICOLON       shift and go to state 49


state 14

    (38) stmnt -> nested_stmnt .

    RBRACE          reduce using rule 38 (stmnt -> nested_stmnt .)
    LBRACE          reduce using rule 38 (stmnt -> nested_stmnt .)
    IF              reduce using rule 38 (stmnt -> nested_stmnt .)
    WHILE           reduce using rule 38 (stmnt -> nested_stmnt .)
    FOR             reduce using rule 38 (stmnt -> nested_stmnt .)
    DO              reduce using rule 38 (stmnt -> nested_stmnt .)
    TIMES           reduce using rule 38 (stmnt -> nested_stmnt .)
    PLUS            reduce using rule 38 (stmnt -> nested_stmnt .)
    MINUS           reduce using rule 38 (stmnt -> nested_stmnt .)
    IDENTIFIER      reduce using rule 38 (stmnt -> nested_stmnt .)
    NUMBER          reduce using rule 38 (stmnt -> nested_stmnt .)
    LPAREN          reduce using rule 38 (stmnt -> nested_stmnt .)
    SEMICOLON       reduce using rule 38 (stmnt -> nested_stmnt .)
    ELSE            reduce using rule 38 (stmnt -> nested_stmnt .)


state 15

    (39) stmnt -> if .

    RBRACE          reduce using rule 39 (stmnt -> if .)
    LBRACE          reduce using rule 39 (stmnt -> if .)
    IF              reduce using rule 39 (stmnt -> if .)
    WHILE           reduce using rule 39 (stmnt -> if .)
    FOR             reduce using rule 39 (stmnt -> if .)
    DO              reduce using rule 39 (stmnt -> if .)
    TIMES           reduce using rule 39 (stmnt -> if .)
    PLUS            reduce using rule 39 (stmnt -> if .)
    MINUS           reduce using rule 39 (stmnt -> if .)
    IDENTIFIER      reduce using rule 39 (stmnt -> if .)
    NUMBER          reduce using rule 39 (stmnt -> if .)
    LPAREN          reduce using rule 39 (stmnt -> if .)
    SEMICOLON       reduce using rule 39 (stmnt -> if .)
    ELSE            reduce using rule 39 (stmnt -> if .)


state 16

    (40) stmnt -> loops .

    RBRACE          reduce using rule 40 (stmnt -> loops .)
    LBRACE          reduce using rule 40 (stmnt -> loops .)
    IF              reduce using rule 40 (stmnt -> loops .)
    WHILE           reduce using rule 40 (stmnt -> loops .)
    FOR             reduce using rule 40 (stmnt -> loops .)
    DO              reduce using rule 40 (stmnt -> loops .)
    TIMES           reduce using rule 40 (stmnt -> loops .)
    PLUS            reduce using rule 40 (stmnt -> loops .)
    MINUS           reduce using rule 40 (stmnt -> loops .)
    IDENTIFIER      reduce using rule 40 (stmnt -> loops .)
    NUMBER          reduce using rule 40 (stmnt -> loops .)
    LPAREN          reduce using rule 40 (stmnt -> loops .)
    SEMICOLON       reduce using rule 40 (stmnt -> loops .)
    ELSE            reduce using rule 40 (stmnt -> loops .)


state 17

    (52) expression_2 -> empty .

    SEMICOLON       reduce using rule 52 (expression_2 -> empty .)
    RPAREN          reduce using rule 52 (expression_2 -> empty .)


state 18

    (53) expression_2 -> expression .
    (55) expression -> expression . COMMA assigning

    SEMICOLON       reduce using rule 53 (expression_2 -> expression .)
    RPAREN          reduce using rule 53 (expression_2 -> expression .)
    COMMA           shift and go to state 50


state 19

    (47) if -> IF . LPAREN expression RPAREN stmnt
    (48) if -> IF . LPAREN expression RPAREN stmnt ELSE stmnt

    LPAREN          shift and go to state 51


state 20

    (81) expression_combination -> LPAREN . expression RPAREN
    (71) cast -> LPAREN . variable_detector_2 RPAREN cast
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (28) variable_detector_2 -> . variable_detector identifier_punctuator_2
    (29) variable_detector_2 -> . variable_detector empty
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    CHAR            shift and go to state 6
    INT             shift and go to state 7
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression                     shift and go to state 52
    variable_detector_2            shift and go to state 53
    cast                           shift and go to state 30
    assigning                      shift and go to state 24
    variable_detector              shift and go to state 54
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 21

    (49) loops -> WHILE . LPAREN expression RPAREN stmnt

    LPAREN          shift and go to state 55


state 22

    (50) loops -> FOR . LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt

    LPAREN          shift and go to state 56


state 23

    (51) loops -> DO . stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    stmnt                          shift and go to state 57
    expression                     shift and go to state 18
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 24

    (54) expression -> assigning .

    COMMA           reduce using rule 54 (expression -> assigning .)
    SEMICOLON       reduce using rule 54 (expression -> assigning .)
    RPAREN          reduce using rule 54 (expression -> assigning .)


state 25

    (56) assigning -> equal_unequal .
    (60) equal_unequal -> equal_unequal . EQ comparison
    (61) equal_unequal -> equal_unequal . NOT_EQ comparison

    COMMA           reduce using rule 56 (assigning -> equal_unequal .)
    SEMICOLON       reduce using rule 56 (assigning -> equal_unequal .)
    RPAREN          reduce using rule 56 (assigning -> equal_unequal .)
    RBRACE          reduce using rule 56 (assigning -> equal_unequal .)
    EQ              shift and go to state 58
    NOT_EQ          shift and go to state 59


state 26

    (57) assigning -> single_operand . ASSIGN assigning
    (58) assigning -> single_operand . PLUSASSIGN assigning
    (70) cast -> single_operand .

    ASSIGN          shift and go to state 60
    PLUSASSIGN      shift and go to state 61
    TIMES           reduce using rule 70 (cast -> single_operand .)
    DIVIDE          reduce using rule 70 (cast -> single_operand .)
    PLUS            reduce using rule 70 (cast -> single_operand .)
    MINUS           reduce using rule 70 (cast -> single_operand .)
    LT              reduce using rule 70 (cast -> single_operand .)
    GT              reduce using rule 70 (cast -> single_operand .)
    LE              reduce using rule 70 (cast -> single_operand .)
    GE              reduce using rule 70 (cast -> single_operand .)
    EQ              reduce using rule 70 (cast -> single_operand .)
    NOT_EQ          reduce using rule 70 (cast -> single_operand .)
    COMMA           reduce using rule 70 (cast -> single_operand .)
    SEMICOLON       reduce using rule 70 (cast -> single_operand .)
    RPAREN          reduce using rule 70 (cast -> single_operand .)
    RBRACE          reduce using rule 70 (cast -> single_operand .)


state 27

    (59) equal_unequal -> comparison .
    (63) comparison -> comparison . LT arithmetic_precedence
    (64) comparison -> comparison . GT arithmetic_precedence
    (65) comparison -> comparison . LE arithmetic_precedence
    (66) comparison -> comparison . GE arithmetic_precedence

    EQ              reduce using rule 59 (equal_unequal -> comparison .)
    NOT_EQ          reduce using rule 59 (equal_unequal -> comparison .)
    COMMA           reduce using rule 59 (equal_unequal -> comparison .)
    SEMICOLON       reduce using rule 59 (equal_unequal -> comparison .)
    RPAREN          reduce using rule 59 (equal_unequal -> comparison .)
    RBRACE          reduce using rule 59 (equal_unequal -> comparison .)
    LT              shift and go to state 62
    GT              shift and go to state 63
    LE              shift and go to state 64
    GE              shift and go to state 65


state 28

    (75) single_operand -> expression_combination .
    (82) expression_combination -> expression_combination . LPAREN assigning RPAREN
    (83) expression_combination -> expression_combination . LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> expression_combination . LPAREN RPAREN

    ASSIGN          reduce using rule 75 (single_operand -> expression_combination .)
    PLUSASSIGN      reduce using rule 75 (single_operand -> expression_combination .)
    TIMES           reduce using rule 75 (single_operand -> expression_combination .)
    DIVIDE          reduce using rule 75 (single_operand -> expression_combination .)
    PLUS            reduce using rule 75 (single_operand -> expression_combination .)
    MINUS           reduce using rule 75 (single_operand -> expression_combination .)
    LT              reduce using rule 75 (single_operand -> expression_combination .)
    GT              reduce using rule 75 (single_operand -> expression_combination .)
    LE              reduce using rule 75 (single_operand -> expression_combination .)
    GE              reduce using rule 75 (single_operand -> expression_combination .)
    EQ              reduce using rule 75 (single_operand -> expression_combination .)
    NOT_EQ          reduce using rule 75 (single_operand -> expression_combination .)
    COMMA           reduce using rule 75 (single_operand -> expression_combination .)
    SEMICOLON       reduce using rule 75 (single_operand -> expression_combination .)
    RPAREN          reduce using rule 75 (single_operand -> expression_combination .)
    RBRACE          reduce using rule 75 (single_operand -> expression_combination .)
    LPAREN          shift and go to state 66


state 29

    (76) single_operand -> TIMES . cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    cast                           shift and go to state 67
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 30

    (67) multiply_division -> cast .

    TIMES           reduce using rule 67 (multiply_division -> cast .)
    DIVIDE          reduce using rule 67 (multiply_division -> cast .)
    PLUS            reduce using rule 67 (multiply_division -> cast .)
    MINUS           reduce using rule 67 (multiply_division -> cast .)
    LT              reduce using rule 67 (multiply_division -> cast .)
    GT              reduce using rule 67 (multiply_division -> cast .)
    LE              reduce using rule 67 (multiply_division -> cast .)
    GE              reduce using rule 67 (multiply_division -> cast .)
    EQ              reduce using rule 67 (multiply_division -> cast .)
    NOT_EQ          reduce using rule 67 (multiply_division -> cast .)
    COMMA           reduce using rule 67 (multiply_division -> cast .)
    SEMICOLON       reduce using rule 67 (multiply_division -> cast .)
    RPAREN          reduce using rule 67 (multiply_division -> cast .)
    RBRACE          reduce using rule 67 (multiply_division -> cast .)


state 31

    (77) single_operand -> PLUS . cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    cast                           shift and go to state 70
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 32

    (78) single_operand -> MINUS . cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    cast                           shift and go to state 71
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 33

    (62) comparison -> arithmetic_precedence .
    (73) arithmetic_precedence -> arithmetic_precedence . PLUS multiply_division
    (74) arithmetic_precedence -> arithmetic_precedence . MINUS multiply_division

    LT              reduce using rule 62 (comparison -> arithmetic_precedence .)
    GT              reduce using rule 62 (comparison -> arithmetic_precedence .)
    LE              reduce using rule 62 (comparison -> arithmetic_precedence .)
    GE              reduce using rule 62 (comparison -> arithmetic_precedence .)
    EQ              reduce using rule 62 (comparison -> arithmetic_precedence .)
    NOT_EQ          reduce using rule 62 (comparison -> arithmetic_precedence .)
    COMMA           reduce using rule 62 (comparison -> arithmetic_precedence .)
    SEMICOLON       reduce using rule 62 (comparison -> arithmetic_precedence .)
    RPAREN          reduce using rule 62 (comparison -> arithmetic_precedence .)
    RBRACE          reduce using rule 62 (comparison -> arithmetic_precedence .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 34

    (79) expression_combination -> IDENTIFIER .

    LPAREN          reduce using rule 79 (expression_combination -> IDENTIFIER .)
    ASSIGN          reduce using rule 79 (expression_combination -> IDENTIFIER .)
    PLUSASSIGN      reduce using rule 79 (expression_combination -> IDENTIFIER .)
    TIMES           reduce using rule 79 (expression_combination -> IDENTIFIER .)
    DIVIDE          reduce using rule 79 (expression_combination -> IDENTIFIER .)
    PLUS            reduce using rule 79 (expression_combination -> IDENTIFIER .)
    MINUS           reduce using rule 79 (expression_combination -> IDENTIFIER .)
    LT              reduce using rule 79 (expression_combination -> IDENTIFIER .)
    GT              reduce using rule 79 (expression_combination -> IDENTIFIER .)
    LE              reduce using rule 79 (expression_combination -> IDENTIFIER .)
    GE              reduce using rule 79 (expression_combination -> IDENTIFIER .)
    EQ              reduce using rule 79 (expression_combination -> IDENTIFIER .)
    NOT_EQ          reduce using rule 79 (expression_combination -> IDENTIFIER .)
    COMMA           reduce using rule 79 (expression_combination -> IDENTIFIER .)
    SEMICOLON       reduce using rule 79 (expression_combination -> IDENTIFIER .)
    RPAREN          reduce using rule 79 (expression_combination -> IDENTIFIER .)
    RBRACE          reduce using rule 79 (expression_combination -> IDENTIFIER .)


state 35

    (80) expression_combination -> NUMBER .

    LPAREN          reduce using rule 80 (expression_combination -> NUMBER .)
    ASSIGN          reduce using rule 80 (expression_combination -> NUMBER .)
    PLUSASSIGN      reduce using rule 80 (expression_combination -> NUMBER .)
    TIMES           reduce using rule 80 (expression_combination -> NUMBER .)
    DIVIDE          reduce using rule 80 (expression_combination -> NUMBER .)
    PLUS            reduce using rule 80 (expression_combination -> NUMBER .)
    MINUS           reduce using rule 80 (expression_combination -> NUMBER .)
    LT              reduce using rule 80 (expression_combination -> NUMBER .)
    GT              reduce using rule 80 (expression_combination -> NUMBER .)
    LE              reduce using rule 80 (expression_combination -> NUMBER .)
    GE              reduce using rule 80 (expression_combination -> NUMBER .)
    EQ              reduce using rule 80 (expression_combination -> NUMBER .)
    NOT_EQ          reduce using rule 80 (expression_combination -> NUMBER .)
    COMMA           reduce using rule 80 (expression_combination -> NUMBER .)
    SEMICOLON       reduce using rule 80 (expression_combination -> NUMBER .)
    RPAREN          reduce using rule 80 (expression_combination -> NUMBER .)
    RBRACE          reduce using rule 80 (expression_combination -> NUMBER .)


state 36

    (72) arithmetic_precedence -> multiply_division .
    (68) multiply_division -> multiply_division . TIMES cast
    (69) multiply_division -> multiply_division . DIVIDE cast

    PLUS            reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    MINUS           reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    LT              reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    GT              reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    LE              reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    GE              reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    EQ              reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    NOT_EQ          reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    COMMA           reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    SEMICOLON       reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    RPAREN          reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    RBRACE          reduce using rule 72 (arithmetic_precedence -> multiply_division .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 37

    (9) variable_starter -> variable_detector assign_detector . SEMICOLON
    (10) variable_starter -> variable_detector assign_detector . COMMA assign_detector SEMICOLON

    SEMICOLON       shift and go to state 76
    COMMA           shift and go to state 77


state 38

    (11) variable_starter -> variable_detector SEMICOLON .

    $end            reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    RBRACE          reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    CHAR            reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    INT             reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    LBRACE          reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    IF              reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    WHILE           reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    FOR             reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    DO              reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    TIMES           reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    PLUS            reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    MINUS           reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    IDENTIFIER      reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    NUMBER          reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    LPAREN          reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)
    SEMICOLON       reduce using rule 11 (variable_starter -> variable_detector SEMICOLON .)


state 39

    (7) assign_detector -> identifier_punctuator .
    (8) assign_detector -> identifier_punctuator . ASSIGN starting_brace
    (16) identifier_punctuator -> identifier_punctuator . LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> identifier_punctuator . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> identifier_punctuator . LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> identifier_punctuator . LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN

    SEMICOLON       reduce using rule 7 (assign_detector -> identifier_punctuator .)
    COMMA           reduce using rule 7 (assign_detector -> identifier_punctuator .)
    ASSIGN          shift and go to state 78
    LPAREN          shift and go to state 79


state 40

    (14) identifier_punctuator -> IDENTIFIER .

    ASSIGN          reduce using rule 14 (identifier_punctuator -> IDENTIFIER .)
    LPAREN          reduce using rule 14 (identifier_punctuator -> IDENTIFIER .)
    SEMICOLON       reduce using rule 14 (identifier_punctuator -> IDENTIFIER .)
    COMMA           reduce using rule 14 (identifier_punctuator -> IDENTIFIER .)
    RPAREN          reduce using rule 14 (identifier_punctuator -> IDENTIFIER .)


state 41

    (15) identifier_punctuator -> LPAREN . identifier_punctuator RPAREN
    (14) identifier_punctuator -> . IDENTIFIER
    (15) identifier_punctuator -> . LPAREN identifier_punctuator RPAREN
    (16) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 40
    LPAREN          shift and go to state 41

    identifier_punctuator          shift and go to state 80

state 42

    (3) variable_detector -> CHAR variable_detector .

    SEMICOLON       reduce using rule 3 (variable_detector -> CHAR variable_detector .)
    IDENTIFIER      reduce using rule 3 (variable_detector -> CHAR variable_detector .)
    LPAREN          reduce using rule 3 (variable_detector -> CHAR variable_detector .)
    RPAREN          reduce using rule 3 (variable_detector -> CHAR variable_detector .)
    COMMA           reduce using rule 3 (variable_detector -> CHAR variable_detector .)


state 43

    (4) variable_detector -> INT variable_detector .

    SEMICOLON       reduce using rule 4 (variable_detector -> INT variable_detector .)
    IDENTIFIER      reduce using rule 4 (variable_detector -> INT variable_detector .)
    LPAREN          reduce using rule 4 (variable_detector -> INT variable_detector .)
    RPAREN          reduce using rule 4 (variable_detector -> INT variable_detector .)
    COMMA           reduce using rule 4 (variable_detector -> INT variable_detector .)


state 44

    (41) nested_stmnt -> LBRACE variable_starter_chains stmnt_chains . RBRACE
    (46) stmnt_chains -> stmnt_chains . stmnt
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    RBRACE          shift and go to state 81
    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    stmnt                          shift and go to state 48
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 45

    (43) nested_stmnt -> LBRACE variable_starter_chains RBRACE .

    $end            reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    RBRACE          reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    LBRACE          reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    IF              reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    WHILE           reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    FOR             reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    DO              reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    TIMES           reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    PLUS            reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    MINUS           reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    IDENTIFIER      reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    NUMBER          reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    LPAREN          reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    SEMICOLON       reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)
    ELSE            reduce using rule 43 (nested_stmnt -> LBRACE variable_starter_chains RBRACE .)


state 46

    (13) variable_starter_chains -> variable_starter_chains variable_starter .

    RBRACE          reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    CHAR            reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    INT             reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    LBRACE          reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    IF              reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    WHILE           reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    FOR             reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    DO              reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    TIMES           reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    PLUS            reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    MINUS           reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    IDENTIFIER      reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    NUMBER          reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    LPAREN          reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)
    SEMICOLON       reduce using rule 13 (variable_starter_chains -> variable_starter_chains variable_starter .)


state 47

    (42) nested_stmnt -> LBRACE stmnt_chains RBRACE .

    $end            reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    RBRACE          reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    LBRACE          reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    IF              reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    WHILE           reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    FOR             reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    DO              reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    TIMES           reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    PLUS            reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    MINUS           reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    IDENTIFIER      reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    NUMBER          reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    LPAREN          reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    SEMICOLON       reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)
    ELSE            reduce using rule 42 (nested_stmnt -> LBRACE stmnt_chains RBRACE .)


state 48

    (46) stmnt_chains -> stmnt_chains stmnt .

    RBRACE          reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    LBRACE          reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    IF              reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    WHILE           reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    FOR             reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    DO              reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    TIMES           reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    PLUS            reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    MINUS           reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    IDENTIFIER      reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    NUMBER          reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    LPAREN          reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)
    SEMICOLON       reduce using rule 46 (stmnt_chains -> stmnt_chains stmnt .)


state 49

    (37) stmnt -> expression_2 SEMICOLON .

    RBRACE          reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    LBRACE          reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    IF              reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    WHILE           reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    FOR             reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    DO              reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    TIMES           reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    PLUS            reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    MINUS           reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    IDENTIFIER      reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    NUMBER          reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    LPAREN          reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    SEMICOLON       reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)
    ELSE            reduce using rule 37 (stmnt -> expression_2 SEMICOLON .)


state 50

    (55) expression -> expression COMMA . assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    assigning                      shift and go to state 82
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 51

    (47) if -> IF LPAREN . expression RPAREN stmnt
    (48) if -> IF LPAREN . expression RPAREN stmnt ELSE stmnt
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression                     shift and go to state 83
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 52

    (81) expression_combination -> LPAREN expression . RPAREN
    (55) expression -> expression . COMMA assigning

    RPAREN          shift and go to state 84
    COMMA           shift and go to state 50


state 53

    (71) cast -> LPAREN variable_detector_2 . RPAREN cast

    RPAREN          shift and go to state 85


state 54

    (28) variable_detector_2 -> variable_detector . identifier_punctuator_2
    (29) variable_detector_2 -> variable_detector . empty
    (30) identifier_punctuator_2 -> . LPAREN identifier_punctuator_2 RPAREN
    (31) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN empty RPAREN
    (34) identifier_punctuator_2 -> . LPAREN parameter_variable_starter RPAREN
    (35) identifier_punctuator_2 -> . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (36) identifier_punctuator_2 -> . LPAREN empty RPAREN
    (85) empty -> .

    LPAREN          shift and go to state 88
    RPAREN          reduce using rule 85 (empty -> .)

    identifier_punctuator_2        shift and go to state 86
    empty                          shift and go to state 87

state 55

    (49) loops -> WHILE LPAREN . expression RPAREN stmnt
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression                     shift and go to state 89
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 56

    (50) loops -> FOR LPAREN . expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression_2                   shift and go to state 90
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 57

    (51) loops -> DO stmnt . WHILE LPAREN expression RPAREN SEMICOLON

    WHILE           shift and go to state 91


state 58

    (60) equal_unequal -> equal_unequal EQ . comparison
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    comparison                     shift and go to state 92
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 59

    (61) equal_unequal -> equal_unequal NOT_EQ . comparison
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    comparison                     shift and go to state 93
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 60

    (57) assigning -> single_operand ASSIGN . assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    single_operand                 shift and go to state 26
    assigning                      shift and go to state 94
    equal_unequal                  shift and go to state 25
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 61

    (58) assigning -> single_operand PLUSASSIGN . assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    single_operand                 shift and go to state 26
    assigning                      shift and go to state 95
    equal_unequal                  shift and go to state 25
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 62

    (63) comparison -> comparison LT . arithmetic_precedence
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    arithmetic_precedence          shift and go to state 96
    multiply_division              shift and go to state 36
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 63

    (64) comparison -> comparison GT . arithmetic_precedence
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    arithmetic_precedence          shift and go to state 97
    multiply_division              shift and go to state 36
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 64

    (65) comparison -> comparison LE . arithmetic_precedence
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    arithmetic_precedence          shift and go to state 98
    multiply_division              shift and go to state 36
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 65

    (66) comparison -> comparison GE . arithmetic_precedence
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    arithmetic_precedence          shift and go to state 99
    multiply_division              shift and go to state 36
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 66

    (82) expression_combination -> expression_combination LPAREN . assigning RPAREN
    (83) expression_combination -> expression_combination LPAREN . assigning COMMA assigning RPAREN
    (84) expression_combination -> expression_combination LPAREN . RPAREN
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    RPAREN          shift and go to state 101
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression_combination         shift and go to state 28
    assigning                      shift and go to state 100
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 67

    (76) single_operand -> TIMES cast .

    ASSIGN          reduce using rule 76 (single_operand -> TIMES cast .)
    PLUSASSIGN      reduce using rule 76 (single_operand -> TIMES cast .)
    TIMES           reduce using rule 76 (single_operand -> TIMES cast .)
    DIVIDE          reduce using rule 76 (single_operand -> TIMES cast .)
    PLUS            reduce using rule 76 (single_operand -> TIMES cast .)
    MINUS           reduce using rule 76 (single_operand -> TIMES cast .)
    LT              reduce using rule 76 (single_operand -> TIMES cast .)
    GT              reduce using rule 76 (single_operand -> TIMES cast .)
    LE              reduce using rule 76 (single_operand -> TIMES cast .)
    GE              reduce using rule 76 (single_operand -> TIMES cast .)
    EQ              reduce using rule 76 (single_operand -> TIMES cast .)
    NOT_EQ          reduce using rule 76 (single_operand -> TIMES cast .)
    COMMA           reduce using rule 76 (single_operand -> TIMES cast .)
    SEMICOLON       reduce using rule 76 (single_operand -> TIMES cast .)
    RPAREN          reduce using rule 76 (single_operand -> TIMES cast .)
    RBRACE          reduce using rule 76 (single_operand -> TIMES cast .)


state 68

    (70) cast -> single_operand .

    ASSIGN          reduce using rule 70 (cast -> single_operand .)
    PLUSASSIGN      reduce using rule 70 (cast -> single_operand .)
    TIMES           reduce using rule 70 (cast -> single_operand .)
    DIVIDE          reduce using rule 70 (cast -> single_operand .)
    PLUS            reduce using rule 70 (cast -> single_operand .)
    MINUS           reduce using rule 70 (cast -> single_operand .)
    LT              reduce using rule 70 (cast -> single_operand .)
    GT              reduce using rule 70 (cast -> single_operand .)
    LE              reduce using rule 70 (cast -> single_operand .)
    GE              reduce using rule 70 (cast -> single_operand .)
    EQ              reduce using rule 70 (cast -> single_operand .)
    NOT_EQ          reduce using rule 70 (cast -> single_operand .)
    COMMA           reduce using rule 70 (cast -> single_operand .)
    SEMICOLON       reduce using rule 70 (cast -> single_operand .)
    RPAREN          reduce using rule 70 (cast -> single_operand .)
    RBRACE          reduce using rule 70 (cast -> single_operand .)


state 69

    (71) cast -> LPAREN . variable_detector_2 RPAREN cast
    (81) expression_combination -> LPAREN . expression RPAREN
    (28) variable_detector_2 -> . variable_detector identifier_punctuator_2
    (29) variable_detector_2 -> . variable_detector empty
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    CHAR            shift and go to state 6
    INT             shift and go to state 7
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    variable_detector_2            shift and go to state 53
    cast                           shift and go to state 30
    expression                     shift and go to state 52
    variable_detector              shift and go to state 54
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 70

    (77) single_operand -> PLUS cast .

    ASSIGN          reduce using rule 77 (single_operand -> PLUS cast .)
    PLUSASSIGN      reduce using rule 77 (single_operand -> PLUS cast .)
    TIMES           reduce using rule 77 (single_operand -> PLUS cast .)
    DIVIDE          reduce using rule 77 (single_operand -> PLUS cast .)
    PLUS            reduce using rule 77 (single_operand -> PLUS cast .)
    MINUS           reduce using rule 77 (single_operand -> PLUS cast .)
    LT              reduce using rule 77 (single_operand -> PLUS cast .)
    GT              reduce using rule 77 (single_operand -> PLUS cast .)
    LE              reduce using rule 77 (single_operand -> PLUS cast .)
    GE              reduce using rule 77 (single_operand -> PLUS cast .)
    EQ              reduce using rule 77 (single_operand -> PLUS cast .)
    NOT_EQ          reduce using rule 77 (single_operand -> PLUS cast .)
    COMMA           reduce using rule 77 (single_operand -> PLUS cast .)
    SEMICOLON       reduce using rule 77 (single_operand -> PLUS cast .)
    RPAREN          reduce using rule 77 (single_operand -> PLUS cast .)
    RBRACE          reduce using rule 77 (single_operand -> PLUS cast .)


state 71

    (78) single_operand -> MINUS cast .

    ASSIGN          reduce using rule 78 (single_operand -> MINUS cast .)
    PLUSASSIGN      reduce using rule 78 (single_operand -> MINUS cast .)
    TIMES           reduce using rule 78 (single_operand -> MINUS cast .)
    DIVIDE          reduce using rule 78 (single_operand -> MINUS cast .)
    PLUS            reduce using rule 78 (single_operand -> MINUS cast .)
    MINUS           reduce using rule 78 (single_operand -> MINUS cast .)
    LT              reduce using rule 78 (single_operand -> MINUS cast .)
    GT              reduce using rule 78 (single_operand -> MINUS cast .)
    LE              reduce using rule 78 (single_operand -> MINUS cast .)
    GE              reduce using rule 78 (single_operand -> MINUS cast .)
    EQ              reduce using rule 78 (single_operand -> MINUS cast .)
    NOT_EQ          reduce using rule 78 (single_operand -> MINUS cast .)
    COMMA           reduce using rule 78 (single_operand -> MINUS cast .)
    SEMICOLON       reduce using rule 78 (single_operand -> MINUS cast .)
    RPAREN          reduce using rule 78 (single_operand -> MINUS cast .)
    RBRACE          reduce using rule 78 (single_operand -> MINUS cast .)


state 72

    (73) arithmetic_precedence -> arithmetic_precedence PLUS . multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    multiply_division              shift and go to state 102
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 73

    (74) arithmetic_precedence -> arithmetic_precedence MINUS . multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    multiply_division              shift and go to state 103
    cast                           shift and go to state 30
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 74

    (68) multiply_division -> multiply_division TIMES . cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    cast                           shift and go to state 104
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 75

    (69) multiply_division -> multiply_division DIVIDE . cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    cast                           shift and go to state 105
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 76

    (9) variable_starter -> variable_detector assign_detector SEMICOLON .

    $end            reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    RBRACE          reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    CHAR            reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    INT             reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    LBRACE          reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    IF              reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    WHILE           reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    FOR             reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    DO              reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    TIMES           reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    PLUS            reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    MINUS           reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    IDENTIFIER      reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    NUMBER          reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    LPAREN          reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)
    SEMICOLON       reduce using rule 9 (variable_starter -> variable_detector assign_detector SEMICOLON .)


state 77

    (10) variable_starter -> variable_detector assign_detector COMMA . assign_detector SEMICOLON
    (7) assign_detector -> . identifier_punctuator
    (8) assign_detector -> . identifier_punctuator ASSIGN starting_brace
    (14) identifier_punctuator -> . IDENTIFIER
    (15) identifier_punctuator -> . LPAREN identifier_punctuator RPAREN
    (16) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 40
    LPAREN          shift and go to state 41

    assign_detector                shift and go to state 106
    identifier_punctuator          shift and go to state 39

state 78

    (8) assign_detector -> identifier_punctuator ASSIGN . starting_brace
    (23) starting_brace -> . assigning
    (24) starting_brace -> . LBRACE starting_brace RBRACE
    (25) starting_brace -> . LBRACE starting_brace COMMA starting_brace RBRACE
    (26) starting_brace -> . LBRACE starting_brace COMMA RBRACE
    (27) starting_brace -> . LBRACE starting_brace COMMA starting_brace COMMA RBRACE
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    LBRACE          shift and go to state 109
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    starting_brace                 shift and go to state 107
    assigning                      shift and go to state 108
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 79

    (16) identifier_punctuator -> identifier_punctuator LPAREN . parameter_variable_starter RPAREN
    (17) identifier_punctuator -> identifier_punctuator LPAREN . parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> identifier_punctuator LPAREN . IDENTIFIER RPAREN
    (19) identifier_punctuator -> identifier_punctuator LPAREN . IDENTIFIER COMMA IDENTIFIER RPAREN
    (20) parameter_variable_starter -> . variable_detector identifier_punctuator
    (21) parameter_variable_starter -> . variable_detector identifier_punctuator_2
    (22) parameter_variable_starter -> . variable_detector empty
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    IDENTIFIER      shift and go to state 111
    CHAR            shift and go to state 6
    INT             shift and go to state 7

    parameter_variable_starter     shift and go to state 110
    variable_detector              shift and go to state 112

state 80

    (15) identifier_punctuator -> LPAREN identifier_punctuator . RPAREN
    (16) identifier_punctuator -> identifier_punctuator . LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> identifier_punctuator . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> identifier_punctuator . LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> identifier_punctuator . LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN

    RPAREN          shift and go to state 113
    LPAREN          shift and go to state 79


state 81

    (41) nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .

    $end            reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    RBRACE          reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    LBRACE          reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    IF              reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    WHILE           reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    FOR             reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    DO              reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    TIMES           reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    PLUS            reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    MINUS           reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    IDENTIFIER      reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    NUMBER          reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    LPAREN          reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    SEMICOLON       reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)
    ELSE            reduce using rule 41 (nested_stmnt -> LBRACE variable_starter_chains stmnt_chains RBRACE .)


state 82

    (55) expression -> expression COMMA assigning .

    COMMA           reduce using rule 55 (expression -> expression COMMA assigning .)
    SEMICOLON       reduce using rule 55 (expression -> expression COMMA assigning .)
    RPAREN          reduce using rule 55 (expression -> expression COMMA assigning .)


state 83

    (47) if -> IF LPAREN expression . RPAREN stmnt
    (48) if -> IF LPAREN expression . RPAREN stmnt ELSE stmnt
    (55) expression -> expression . COMMA assigning

    RPAREN          shift and go to state 114
    COMMA           shift and go to state 50


state 84

    (81) expression_combination -> LPAREN expression RPAREN .

    LPAREN          reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    ASSIGN          reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    PLUSASSIGN      reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    LT              reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    GT              reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    LE              reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    GE              reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    EQ              reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 81 (expression_combination -> LPAREN expression RPAREN .)


state 85

    (71) cast -> LPAREN variable_detector_2 RPAREN . cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN

    LPAREN          shift and go to state 69
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35

    cast                           shift and go to state 115
    single_operand                 shift and go to state 68
    expression_combination         shift and go to state 28

state 86

    (28) variable_detector_2 -> variable_detector identifier_punctuator_2 .
    (31) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN empty RPAREN

    RPAREN          reduce using rule 28 (variable_detector_2 -> variable_detector identifier_punctuator_2 .)
    LPAREN          shift and go to state 116


state 87

    (29) variable_detector_2 -> variable_detector empty .

    RPAREN          reduce using rule 29 (variable_detector_2 -> variable_detector empty .)


state 88

    (30) identifier_punctuator_2 -> LPAREN . identifier_punctuator_2 RPAREN
    (34) identifier_punctuator_2 -> LPAREN . parameter_variable_starter RPAREN
    (35) identifier_punctuator_2 -> LPAREN . parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (36) identifier_punctuator_2 -> LPAREN . empty RPAREN
    (30) identifier_punctuator_2 -> . LPAREN identifier_punctuator_2 RPAREN
    (31) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN empty RPAREN
    (34) identifier_punctuator_2 -> . LPAREN parameter_variable_starter RPAREN
    (35) identifier_punctuator_2 -> . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (36) identifier_punctuator_2 -> . LPAREN empty RPAREN
    (20) parameter_variable_starter -> . variable_detector identifier_punctuator
    (21) parameter_variable_starter -> . variable_detector identifier_punctuator_2
    (22) parameter_variable_starter -> . variable_detector empty
    (85) empty -> .
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    LPAREN          shift and go to state 88
    RPAREN          reduce using rule 85 (empty -> .)
    CHAR            shift and go to state 6
    INT             shift and go to state 7

    identifier_punctuator_2        shift and go to state 117
    parameter_variable_starter     shift and go to state 118
    empty                          shift and go to state 119
    variable_detector              shift and go to state 112

state 89

    (49) loops -> WHILE LPAREN expression . RPAREN stmnt
    (55) expression -> expression . COMMA assigning

    RPAREN          shift and go to state 120
    COMMA           shift and go to state 50


state 90

    (50) loops -> FOR LPAREN expression_2 . SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt

    SEMICOLON       shift and go to state 121


state 91

    (51) loops -> DO stmnt WHILE . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 122


state 92

    (60) equal_unequal -> equal_unequal EQ comparison .
    (63) comparison -> comparison . LT arithmetic_precedence
    (64) comparison -> comparison . GT arithmetic_precedence
    (65) comparison -> comparison . LE arithmetic_precedence
    (66) comparison -> comparison . GE arithmetic_precedence

    EQ              reduce using rule 60 (equal_unequal -> equal_unequal EQ comparison .)
    NOT_EQ          reduce using rule 60 (equal_unequal -> equal_unequal EQ comparison .)
    COMMA           reduce using rule 60 (equal_unequal -> equal_unequal EQ comparison .)
    SEMICOLON       reduce using rule 60 (equal_unequal -> equal_unequal EQ comparison .)
    RPAREN          reduce using rule 60 (equal_unequal -> equal_unequal EQ comparison .)
    RBRACE          reduce using rule 60 (equal_unequal -> equal_unequal EQ comparison .)
    LT              shift and go to state 62
    GT              shift and go to state 63
    LE              shift and go to state 64
    GE              shift and go to state 65


state 93

    (61) equal_unequal -> equal_unequal NOT_EQ comparison .
    (63) comparison -> comparison . LT arithmetic_precedence
    (64) comparison -> comparison . GT arithmetic_precedence
    (65) comparison -> comparison . LE arithmetic_precedence
    (66) comparison -> comparison . GE arithmetic_precedence

    EQ              reduce using rule 61 (equal_unequal -> equal_unequal NOT_EQ comparison .)
    NOT_EQ          reduce using rule 61 (equal_unequal -> equal_unequal NOT_EQ comparison .)
    COMMA           reduce using rule 61 (equal_unequal -> equal_unequal NOT_EQ comparison .)
    SEMICOLON       reduce using rule 61 (equal_unequal -> equal_unequal NOT_EQ comparison .)
    RPAREN          reduce using rule 61 (equal_unequal -> equal_unequal NOT_EQ comparison .)
    RBRACE          reduce using rule 61 (equal_unequal -> equal_unequal NOT_EQ comparison .)
    LT              shift and go to state 62
    GT              shift and go to state 63
    LE              shift and go to state 64
    GE              shift and go to state 65


state 94

    (57) assigning -> single_operand ASSIGN assigning .

    COMMA           reduce using rule 57 (assigning -> single_operand ASSIGN assigning .)
    SEMICOLON       reduce using rule 57 (assigning -> single_operand ASSIGN assigning .)
    RPAREN          reduce using rule 57 (assigning -> single_operand ASSIGN assigning .)
    RBRACE          reduce using rule 57 (assigning -> single_operand ASSIGN assigning .)


state 95

    (58) assigning -> single_operand PLUSASSIGN assigning .

    COMMA           reduce using rule 58 (assigning -> single_operand PLUSASSIGN assigning .)
    SEMICOLON       reduce using rule 58 (assigning -> single_operand PLUSASSIGN assigning .)
    RPAREN          reduce using rule 58 (assigning -> single_operand PLUSASSIGN assigning .)
    RBRACE          reduce using rule 58 (assigning -> single_operand PLUSASSIGN assigning .)


state 96

    (63) comparison -> comparison LT arithmetic_precedence .
    (73) arithmetic_precedence -> arithmetic_precedence . PLUS multiply_division
    (74) arithmetic_precedence -> arithmetic_precedence . MINUS multiply_division

    LT              reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    GT              reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    LE              reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    GE              reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    EQ              reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    NOT_EQ          reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    COMMA           reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    SEMICOLON       reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    RPAREN          reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    RBRACE          reduce using rule 63 (comparison -> comparison LT arithmetic_precedence .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 97

    (64) comparison -> comparison GT arithmetic_precedence .
    (73) arithmetic_precedence -> arithmetic_precedence . PLUS multiply_division
    (74) arithmetic_precedence -> arithmetic_precedence . MINUS multiply_division

    LT              reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    GT              reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    LE              reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    GE              reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    EQ              reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    NOT_EQ          reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    COMMA           reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    SEMICOLON       reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    RPAREN          reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    RBRACE          reduce using rule 64 (comparison -> comparison GT arithmetic_precedence .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 98

    (65) comparison -> comparison LE arithmetic_precedence .
    (73) arithmetic_precedence -> arithmetic_precedence . PLUS multiply_division
    (74) arithmetic_precedence -> arithmetic_precedence . MINUS multiply_division

    LT              reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    GT              reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    LE              reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    GE              reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    EQ              reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    NOT_EQ          reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    COMMA           reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    SEMICOLON       reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    RPAREN          reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    RBRACE          reduce using rule 65 (comparison -> comparison LE arithmetic_precedence .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 99

    (66) comparison -> comparison GE arithmetic_precedence .
    (73) arithmetic_precedence -> arithmetic_precedence . PLUS multiply_division
    (74) arithmetic_precedence -> arithmetic_precedence . MINUS multiply_division

    LT              reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    GT              reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    LE              reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    GE              reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    EQ              reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    NOT_EQ          reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    COMMA           reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    SEMICOLON       reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    RPAREN          reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    RBRACE          reduce using rule 66 (comparison -> comparison GE arithmetic_precedence .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 100

    (82) expression_combination -> expression_combination LPAREN assigning . RPAREN
    (83) expression_combination -> expression_combination LPAREN assigning . COMMA assigning RPAREN

    RPAREN          shift and go to state 123
    COMMA           shift and go to state 124


state 101

    (84) expression_combination -> expression_combination LPAREN RPAREN .

    LPAREN          reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    ASSIGN          reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    PLUSASSIGN      reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    TIMES           reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    DIVIDE          reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    PLUS            reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    MINUS           reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    LT              reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    GT              reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    LE              reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    GE              reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    EQ              reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    NOT_EQ          reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    COMMA           reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    SEMICOLON       reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    RPAREN          reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)
    RBRACE          reduce using rule 84 (expression_combination -> expression_combination LPAREN RPAREN .)


state 102

    (73) arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .
    (68) multiply_division -> multiply_division . TIMES cast
    (69) multiply_division -> multiply_division . DIVIDE cast

    PLUS            reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    MINUS           reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    LT              reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    GT              reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    LE              reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    GE              reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    EQ              reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    NOT_EQ          reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    COMMA           reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    SEMICOLON       reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    RPAREN          reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    RBRACE          reduce using rule 73 (arithmetic_precedence -> arithmetic_precedence PLUS multiply_division .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 103

    (74) arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .
    (68) multiply_division -> multiply_division . TIMES cast
    (69) multiply_division -> multiply_division . DIVIDE cast

    PLUS            reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    MINUS           reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    LT              reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    GT              reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    LE              reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    GE              reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    EQ              reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    NOT_EQ          reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    COMMA           reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    SEMICOLON       reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    RPAREN          reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    RBRACE          reduce using rule 74 (arithmetic_precedence -> arithmetic_precedence MINUS multiply_division .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 75


state 104

    (68) multiply_division -> multiply_division TIMES cast .

    TIMES           reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    DIVIDE          reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    PLUS            reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    MINUS           reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    LT              reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    GT              reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    LE              reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    GE              reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    EQ              reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    NOT_EQ          reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    COMMA           reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    SEMICOLON       reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    RPAREN          reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)
    RBRACE          reduce using rule 68 (multiply_division -> multiply_division TIMES cast .)


state 105

    (69) multiply_division -> multiply_division DIVIDE cast .

    TIMES           reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    DIVIDE          reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    PLUS            reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    MINUS           reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    LT              reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    GT              reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    LE              reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    GE              reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    EQ              reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    NOT_EQ          reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    COMMA           reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    SEMICOLON       reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    RPAREN          reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)
    RBRACE          reduce using rule 69 (multiply_division -> multiply_division DIVIDE cast .)


state 106

    (10) variable_starter -> variable_detector assign_detector COMMA assign_detector . SEMICOLON

    SEMICOLON       shift and go to state 125


state 107

    (8) assign_detector -> identifier_punctuator ASSIGN starting_brace .

    SEMICOLON       reduce using rule 8 (assign_detector -> identifier_punctuator ASSIGN starting_brace .)
    COMMA           reduce using rule 8 (assign_detector -> identifier_punctuator ASSIGN starting_brace .)


state 108

    (23) starting_brace -> assigning .

    SEMICOLON       reduce using rule 23 (starting_brace -> assigning .)
    COMMA           reduce using rule 23 (starting_brace -> assigning .)
    RBRACE          reduce using rule 23 (starting_brace -> assigning .)


state 109

    (24) starting_brace -> LBRACE . starting_brace RBRACE
    (25) starting_brace -> LBRACE . starting_brace COMMA starting_brace RBRACE
    (26) starting_brace -> LBRACE . starting_brace COMMA RBRACE
    (27) starting_brace -> LBRACE . starting_brace COMMA starting_brace COMMA RBRACE
    (23) starting_brace -> . assigning
    (24) starting_brace -> . LBRACE starting_brace RBRACE
    (25) starting_brace -> . LBRACE starting_brace COMMA starting_brace RBRACE
    (26) starting_brace -> . LBRACE starting_brace COMMA RBRACE
    (27) starting_brace -> . LBRACE starting_brace COMMA starting_brace COMMA RBRACE
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    LBRACE          shift and go to state 109
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    starting_brace                 shift and go to state 126
    assigning                      shift and go to state 108
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 110

    (16) identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter . RPAREN
    (17) identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter . COMMA parameter_variable_starter RPAREN

    RPAREN          shift and go to state 127
    COMMA           shift and go to state 128


state 111

    (18) identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER . RPAREN
    (19) identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER . COMMA IDENTIFIER RPAREN

    RPAREN          shift and go to state 129
    COMMA           shift and go to state 130


state 112

    (20) parameter_variable_starter -> variable_detector . identifier_punctuator
    (21) parameter_variable_starter -> variable_detector . identifier_punctuator_2
    (22) parameter_variable_starter -> variable_detector . empty
    (14) identifier_punctuator -> . IDENTIFIER
    (15) identifier_punctuator -> . LPAREN identifier_punctuator RPAREN
    (16) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN
    (30) identifier_punctuator_2 -> . LPAREN identifier_punctuator_2 RPAREN
    (31) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN empty RPAREN
    (34) identifier_punctuator_2 -> . LPAREN parameter_variable_starter RPAREN
    (35) identifier_punctuator_2 -> . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (36) identifier_punctuator_2 -> . LPAREN empty RPAREN
    (85) empty -> .

    IDENTIFIER      shift and go to state 40
    LPAREN          shift and go to state 134
    RPAREN          reduce using rule 85 (empty -> .)
    COMMA           reduce using rule 85 (empty -> .)

    identifier_punctuator          shift and go to state 131
    identifier_punctuator_2        shift and go to state 132
    empty                          shift and go to state 133

state 113

    (15) identifier_punctuator -> LPAREN identifier_punctuator RPAREN .

    ASSIGN          reduce using rule 15 (identifier_punctuator -> LPAREN identifier_punctuator RPAREN .)
    LPAREN          reduce using rule 15 (identifier_punctuator -> LPAREN identifier_punctuator RPAREN .)
    SEMICOLON       reduce using rule 15 (identifier_punctuator -> LPAREN identifier_punctuator RPAREN .)
    COMMA           reduce using rule 15 (identifier_punctuator -> LPAREN identifier_punctuator RPAREN .)
    RPAREN          reduce using rule 15 (identifier_punctuator -> LPAREN identifier_punctuator RPAREN .)


state 114

    (47) if -> IF LPAREN expression RPAREN . stmnt
    (48) if -> IF LPAREN expression RPAREN . stmnt ELSE stmnt
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression                     shift and go to state 18
    stmnt                          shift and go to state 135
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 115

    (71) cast -> LPAREN variable_detector_2 RPAREN cast .

    TIMES           reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    DIVIDE          reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    PLUS            reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    MINUS           reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    LT              reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    GT              reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    LE              reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    GE              reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    EQ              reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    NOT_EQ          reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    COMMA           reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    SEMICOLON       reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    RPAREN          reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    ASSIGN          reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    PLUSASSIGN      reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)
    RBRACE          reduce using rule 71 (cast -> LPAREN variable_detector_2 RPAREN cast .)


state 116

    (31) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN . parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN . parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN . empty RPAREN
    (20) parameter_variable_starter -> . variable_detector identifier_punctuator
    (21) parameter_variable_starter -> . variable_detector identifier_punctuator_2
    (22) parameter_variable_starter -> . variable_detector empty
    (85) empty -> .
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    RPAREN          reduce using rule 85 (empty -> .)
    CHAR            shift and go to state 6
    INT             shift and go to state 7

    parameter_variable_starter     shift and go to state 136
    empty                          shift and go to state 137
    variable_detector              shift and go to state 112

state 117

    (30) identifier_punctuator_2 -> LPAREN identifier_punctuator_2 . RPAREN
    (31) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN empty RPAREN

    RPAREN          shift and go to state 138
    LPAREN          shift and go to state 116


state 118

    (34) identifier_punctuator_2 -> LPAREN parameter_variable_starter . RPAREN
    (35) identifier_punctuator_2 -> LPAREN parameter_variable_starter . COMMA parameter_variable_starter RPAREN

    RPAREN          shift and go to state 139
    COMMA           shift and go to state 140


state 119

    (36) identifier_punctuator_2 -> LPAREN empty . RPAREN

    RPAREN          shift and go to state 141


state 120

    (49) loops -> WHILE LPAREN expression RPAREN . stmnt
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression                     shift and go to state 18
    stmnt                          shift and go to state 142
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 121

    (50) loops -> FOR LPAREN expression_2 SEMICOLON . expression_2 SEMICOLON expression_2 RPAREN stmnt
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression_2                   shift and go to state 143
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 122

    (51) loops -> DO stmnt WHILE LPAREN . expression RPAREN SEMICOLON
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression                     shift and go to state 144
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 123

    (82) expression_combination -> expression_combination LPAREN assigning RPAREN .

    LPAREN          reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    ASSIGN          reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    PLUSASSIGN      reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    TIMES           reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    DIVIDE          reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    PLUS            reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    MINUS           reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    LT              reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    GT              reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    LE              reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    GE              reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    EQ              reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    NOT_EQ          reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    COMMA           reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    SEMICOLON       reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    RPAREN          reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)
    RBRACE          reduce using rule 82 (expression_combination -> expression_combination LPAREN assigning RPAREN .)


state 124

    (83) expression_combination -> expression_combination LPAREN assigning COMMA . assigning RPAREN
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression_combination         shift and go to state 28
    assigning                      shift and go to state 145
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 125

    (10) variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .

    $end            reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    RBRACE          reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    CHAR            reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    INT             reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    LBRACE          reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    IF              reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    WHILE           reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    FOR             reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    DO              reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    TIMES           reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    PLUS            reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    MINUS           reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    IDENTIFIER      reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    NUMBER          reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    LPAREN          reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)
    SEMICOLON       reduce using rule 10 (variable_starter -> variable_detector assign_detector COMMA assign_detector SEMICOLON .)


state 126

    (24) starting_brace -> LBRACE starting_brace . RBRACE
    (25) starting_brace -> LBRACE starting_brace . COMMA starting_brace RBRACE
    (26) starting_brace -> LBRACE starting_brace . COMMA RBRACE
    (27) starting_brace -> LBRACE starting_brace . COMMA starting_brace COMMA RBRACE

    RBRACE          shift and go to state 146
    COMMA           shift and go to state 147


state 127

    (16) identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter RPAREN .

    ASSIGN          reduce using rule 16 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter RPAREN .)
    LPAREN          reduce using rule 16 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter RPAREN .)
    SEMICOLON       reduce using rule 16 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter RPAREN .)
    COMMA           reduce using rule 16 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter RPAREN .)
    RPAREN          reduce using rule 16 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter RPAREN .)


state 128

    (17) identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA . parameter_variable_starter RPAREN
    (20) parameter_variable_starter -> . variable_detector identifier_punctuator
    (21) parameter_variable_starter -> . variable_detector identifier_punctuator_2
    (22) parameter_variable_starter -> . variable_detector empty
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    CHAR            shift and go to state 6
    INT             shift and go to state 7

    parameter_variable_starter     shift and go to state 148
    variable_detector              shift and go to state 112

state 129

    (18) identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER RPAREN .

    ASSIGN          reduce using rule 18 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER RPAREN .)
    LPAREN          reduce using rule 18 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER RPAREN .)
    SEMICOLON       reduce using rule 18 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER RPAREN .)
    COMMA           reduce using rule 18 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER RPAREN .)
    RPAREN          reduce using rule 18 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER RPAREN .)


state 130

    (19) identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 149


state 131

    (20) parameter_variable_starter -> variable_detector identifier_punctuator .
    (16) identifier_punctuator -> identifier_punctuator . LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> identifier_punctuator . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> identifier_punctuator . LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> identifier_punctuator . LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN

    RPAREN          reduce using rule 20 (parameter_variable_starter -> variable_detector identifier_punctuator .)
    COMMA           reduce using rule 20 (parameter_variable_starter -> variable_detector identifier_punctuator .)
    LPAREN          shift and go to state 79


state 132

    (21) parameter_variable_starter -> variable_detector identifier_punctuator_2 .
    (31) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> identifier_punctuator_2 . LPAREN empty RPAREN

    RPAREN          reduce using rule 21 (parameter_variable_starter -> variable_detector identifier_punctuator_2 .)
    COMMA           reduce using rule 21 (parameter_variable_starter -> variable_detector identifier_punctuator_2 .)
    LPAREN          shift and go to state 116


state 133

    (22) parameter_variable_starter -> variable_detector empty .

    RPAREN          reduce using rule 22 (parameter_variable_starter -> variable_detector empty .)
    COMMA           reduce using rule 22 (parameter_variable_starter -> variable_detector empty .)


state 134

    (15) identifier_punctuator -> LPAREN . identifier_punctuator RPAREN
    (30) identifier_punctuator_2 -> LPAREN . identifier_punctuator_2 RPAREN
    (34) identifier_punctuator_2 -> LPAREN . parameter_variable_starter RPAREN
    (35) identifier_punctuator_2 -> LPAREN . parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (36) identifier_punctuator_2 -> LPAREN . empty RPAREN
    (14) identifier_punctuator -> . IDENTIFIER
    (15) identifier_punctuator -> . LPAREN identifier_punctuator RPAREN
    (16) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter RPAREN
    (17) identifier_punctuator -> . identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (18) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER RPAREN
    (19) identifier_punctuator -> . identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN
    (30) identifier_punctuator_2 -> . LPAREN identifier_punctuator_2 RPAREN
    (31) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN
    (32) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (33) identifier_punctuator_2 -> . identifier_punctuator_2 LPAREN empty RPAREN
    (34) identifier_punctuator_2 -> . LPAREN parameter_variable_starter RPAREN
    (35) identifier_punctuator_2 -> . LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN
    (36) identifier_punctuator_2 -> . LPAREN empty RPAREN
    (20) parameter_variable_starter -> . variable_detector identifier_punctuator
    (21) parameter_variable_starter -> . variable_detector identifier_punctuator_2
    (22) parameter_variable_starter -> . variable_detector empty
    (85) empty -> .
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    IDENTIFIER      shift and go to state 40
    LPAREN          shift and go to state 134
    RPAREN          reduce using rule 85 (empty -> .)
    CHAR            shift and go to state 6
    INT             shift and go to state 7

    identifier_punctuator          shift and go to state 80
    identifier_punctuator_2        shift and go to state 117
    parameter_variable_starter     shift and go to state 118
    empty                          shift and go to state 119
    variable_detector              shift and go to state 112

state 135

    (47) if -> IF LPAREN expression RPAREN stmnt .
    (48) if -> IF LPAREN expression RPAREN stmnt . ELSE stmnt

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    LBRACE          reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    IF              reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    WHILE           reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    FOR             reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    DO              reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    TIMES           reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    PLUS            reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    MINUS           reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    IDENTIFIER      reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    NUMBER          reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    LPAREN          reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    SEMICOLON       reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .)
    ELSE            shift and go to state 150

  ! ELSE            [ reduce using rule 47 (if -> IF LPAREN expression RPAREN stmnt .) ]


state 136

    (31) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter . RPAREN
    (32) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter . COMMA parameter_variable_starter RPAREN

    RPAREN          shift and go to state 151
    COMMA           shift and go to state 152


state 137

    (33) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN empty . RPAREN

    RPAREN          shift and go to state 153


state 138

    (30) identifier_punctuator_2 -> LPAREN identifier_punctuator_2 RPAREN .

    LPAREN          reduce using rule 30 (identifier_punctuator_2 -> LPAREN identifier_punctuator_2 RPAREN .)
    RPAREN          reduce using rule 30 (identifier_punctuator_2 -> LPAREN identifier_punctuator_2 RPAREN .)
    COMMA           reduce using rule 30 (identifier_punctuator_2 -> LPAREN identifier_punctuator_2 RPAREN .)


state 139

    (34) identifier_punctuator_2 -> LPAREN parameter_variable_starter RPAREN .

    LPAREN          reduce using rule 34 (identifier_punctuator_2 -> LPAREN parameter_variable_starter RPAREN .)
    RPAREN          reduce using rule 34 (identifier_punctuator_2 -> LPAREN parameter_variable_starter RPAREN .)
    COMMA           reduce using rule 34 (identifier_punctuator_2 -> LPAREN parameter_variable_starter RPAREN .)


state 140

    (35) identifier_punctuator_2 -> LPAREN parameter_variable_starter COMMA . parameter_variable_starter RPAREN
    (20) parameter_variable_starter -> . variable_detector identifier_punctuator
    (21) parameter_variable_starter -> . variable_detector identifier_punctuator_2
    (22) parameter_variable_starter -> . variable_detector empty
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    CHAR            shift and go to state 6
    INT             shift and go to state 7

    parameter_variable_starter     shift and go to state 154
    variable_detector              shift and go to state 112

state 141

    (36) identifier_punctuator_2 -> LPAREN empty RPAREN .

    LPAREN          reduce using rule 36 (identifier_punctuator_2 -> LPAREN empty RPAREN .)
    RPAREN          reduce using rule 36 (identifier_punctuator_2 -> LPAREN empty RPAREN .)
    COMMA           reduce using rule 36 (identifier_punctuator_2 -> LPAREN empty RPAREN .)


state 142

    (49) loops -> WHILE LPAREN expression RPAREN stmnt .

    RBRACE          reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    LBRACE          reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    IF              reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    WHILE           reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    FOR             reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    DO              reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    TIMES           reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    PLUS            reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    MINUS           reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    IDENTIFIER      reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    NUMBER          reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    LPAREN          reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    SEMICOLON       reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)
    ELSE            reduce using rule 49 (loops -> WHILE LPAREN expression RPAREN stmnt .)


state 143

    (50) loops -> FOR LPAREN expression_2 SEMICOLON expression_2 . SEMICOLON expression_2 RPAREN stmnt

    SEMICOLON       shift and go to state 155


state 144

    (51) loops -> DO stmnt WHILE LPAREN expression . RPAREN SEMICOLON
    (55) expression -> expression . COMMA assigning

    RPAREN          shift and go to state 156
    COMMA           shift and go to state 50


state 145

    (83) expression_combination -> expression_combination LPAREN assigning COMMA assigning . RPAREN

    RPAREN          shift and go to state 157


state 146

    (24) starting_brace -> LBRACE starting_brace RBRACE .

    SEMICOLON       reduce using rule 24 (starting_brace -> LBRACE starting_brace RBRACE .)
    COMMA           reduce using rule 24 (starting_brace -> LBRACE starting_brace RBRACE .)
    RBRACE          reduce using rule 24 (starting_brace -> LBRACE starting_brace RBRACE .)


state 147

    (25) starting_brace -> LBRACE starting_brace COMMA . starting_brace RBRACE
    (26) starting_brace -> LBRACE starting_brace COMMA . RBRACE
    (27) starting_brace -> LBRACE starting_brace COMMA . starting_brace COMMA RBRACE
    (23) starting_brace -> . assigning
    (24) starting_brace -> . LBRACE starting_brace RBRACE
    (25) starting_brace -> . LBRACE starting_brace COMMA starting_brace RBRACE
    (26) starting_brace -> . LBRACE starting_brace COMMA RBRACE
    (27) starting_brace -> . LBRACE starting_brace COMMA starting_brace COMMA RBRACE
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    RBRACE          shift and go to state 159
    LBRACE          shift and go to state 109
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    starting_brace                 shift and go to state 158
    assigning                      shift and go to state 108
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 148

    (17) identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter . RPAREN

    RPAREN          shift and go to state 160


state 149

    (19) identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER . RPAREN

    RPAREN          shift and go to state 161


state 150

    (48) if -> IF LPAREN expression RPAREN stmnt ELSE . stmnt
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression                     shift and go to state 18
    stmnt                          shift and go to state 162
    expression_2                   shift and go to state 13
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 151

    (31) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN .

    LPAREN          reduce using rule 31 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN .)
    RPAREN          reduce using rule 31 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN .)
    COMMA           reduce using rule 31 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter RPAREN .)


state 152

    (32) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter COMMA . parameter_variable_starter RPAREN
    (20) parameter_variable_starter -> . variable_detector identifier_punctuator
    (21) parameter_variable_starter -> . variable_detector identifier_punctuator_2
    (22) parameter_variable_starter -> . variable_detector empty
    (3) variable_detector -> . CHAR variable_detector
    (4) variable_detector -> . INT variable_detector
    (5) variable_detector -> . CHAR
    (6) variable_detector -> . INT

    CHAR            shift and go to state 6
    INT             shift and go to state 7

    parameter_variable_starter     shift and go to state 163
    variable_detector              shift and go to state 112

state 153

    (33) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN empty RPAREN .

    LPAREN          reduce using rule 33 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN empty RPAREN .)
    RPAREN          reduce using rule 33 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN empty RPAREN .)
    COMMA           reduce using rule 33 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN empty RPAREN .)


state 154

    (35) identifier_punctuator_2 -> LPAREN parameter_variable_starter COMMA parameter_variable_starter . RPAREN

    RPAREN          shift and go to state 164


state 155

    (50) loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON . expression_2 RPAREN stmnt
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    RPAREN          reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression_2                   shift and go to state 165
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 156

    (51) loops -> DO stmnt WHILE LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 166


state 157

    (83) expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .

    LPAREN          reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    ASSIGN          reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    PLUSASSIGN      reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    TIMES           reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    DIVIDE          reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    PLUS            reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    MINUS           reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    LT              reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    GT              reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    LE              reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    GE              reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    EQ              reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    NOT_EQ          reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    COMMA           reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    SEMICOLON       reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    RPAREN          reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)
    RBRACE          reduce using rule 83 (expression_combination -> expression_combination LPAREN assigning COMMA assigning RPAREN .)


state 158

    (25) starting_brace -> LBRACE starting_brace COMMA starting_brace . RBRACE
    (27) starting_brace -> LBRACE starting_brace COMMA starting_brace . COMMA RBRACE

    RBRACE          shift and go to state 168
    COMMA           shift and go to state 167


state 159

    (26) starting_brace -> LBRACE starting_brace COMMA RBRACE .

    SEMICOLON       reduce using rule 26 (starting_brace -> LBRACE starting_brace COMMA RBRACE .)
    COMMA           reduce using rule 26 (starting_brace -> LBRACE starting_brace COMMA RBRACE .)
    RBRACE          reduce using rule 26 (starting_brace -> LBRACE starting_brace COMMA RBRACE .)


state 160

    (17) identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .

    ASSIGN          reduce using rule 17 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    LPAREN          reduce using rule 17 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    SEMICOLON       reduce using rule 17 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    COMMA           reduce using rule 17 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    RPAREN          reduce using rule 17 (identifier_punctuator -> identifier_punctuator LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)


state 161

    (19) identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN .

    ASSIGN          reduce using rule 19 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN .)
    LPAREN          reduce using rule 19 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN .)
    SEMICOLON       reduce using rule 19 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN .)
    COMMA           reduce using rule 19 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN .)
    RPAREN          reduce using rule 19 (identifier_punctuator -> identifier_punctuator LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN .)


state 162

    (48) if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .

    RBRACE          reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    LBRACE          reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    IF              reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    WHILE           reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    FOR             reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    DO              reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    TIMES           reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    PLUS            reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    MINUS           reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    IDENTIFIER      reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    NUMBER          reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    LPAREN          reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    SEMICOLON       reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)
    ELSE            reduce using rule 48 (if -> IF LPAREN expression RPAREN stmnt ELSE stmnt .)


state 163

    (32) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter . RPAREN

    RPAREN          shift and go to state 169


state 164

    (35) identifier_punctuator_2 -> LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .

    LPAREN          reduce using rule 35 (identifier_punctuator_2 -> LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    RPAREN          reduce using rule 35 (identifier_punctuator_2 -> LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    COMMA           reduce using rule 35 (identifier_punctuator_2 -> LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)


state 165

    (50) loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 . RPAREN stmnt

    RPAREN          shift and go to state 170


state 166

    (51) loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .

    RBRACE          reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    LBRACE          reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    DO              reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    TIMES           reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    PLUS            reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    NUMBER          reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    LPAREN          reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)
    ELSE            reduce using rule 51 (loops -> DO stmnt WHILE LPAREN expression RPAREN SEMICOLON .)


state 167

    (27) starting_brace -> LBRACE starting_brace COMMA starting_brace COMMA . RBRACE

    RBRACE          shift and go to state 171


state 168

    (25) starting_brace -> LBRACE starting_brace COMMA starting_brace RBRACE .

    SEMICOLON       reduce using rule 25 (starting_brace -> LBRACE starting_brace COMMA starting_brace RBRACE .)
    COMMA           reduce using rule 25 (starting_brace -> LBRACE starting_brace COMMA starting_brace RBRACE .)
    RBRACE          reduce using rule 25 (starting_brace -> LBRACE starting_brace COMMA starting_brace RBRACE .)


state 169

    (32) identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .

    LPAREN          reduce using rule 32 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    RPAREN          reduce using rule 32 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)
    COMMA           reduce using rule 32 (identifier_punctuator_2 -> identifier_punctuator_2 LPAREN parameter_variable_starter COMMA parameter_variable_starter RPAREN .)


state 170

    (50) loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN . stmnt
    (37) stmnt -> . expression_2 SEMICOLON
    (38) stmnt -> . nested_stmnt
    (39) stmnt -> . if
    (40) stmnt -> . loops
    (52) expression_2 -> . empty
    (53) expression_2 -> . expression
    (41) nested_stmnt -> . LBRACE variable_starter_chains stmnt_chains RBRACE
    (42) nested_stmnt -> . LBRACE stmnt_chains RBRACE
    (43) nested_stmnt -> . LBRACE variable_starter_chains RBRACE
    (44) nested_stmnt -> . LBRACE RBRACE
    (47) if -> . IF LPAREN expression RPAREN stmnt
    (48) if -> . IF LPAREN expression RPAREN stmnt ELSE stmnt
    (49) loops -> . WHILE LPAREN expression RPAREN stmnt
    (50) loops -> . FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt
    (51) loops -> . DO stmnt WHILE LPAREN expression RPAREN SEMICOLON
    (85) empty -> .
    (54) expression -> . assigning
    (55) expression -> . expression COMMA assigning
    (56) assigning -> . equal_unequal
    (57) assigning -> . single_operand ASSIGN assigning
    (58) assigning -> . single_operand PLUSASSIGN assigning
    (59) equal_unequal -> . comparison
    (60) equal_unequal -> . equal_unequal EQ comparison
    (61) equal_unequal -> . equal_unequal NOT_EQ comparison
    (75) single_operand -> . expression_combination
    (76) single_operand -> . TIMES cast
    (77) single_operand -> . PLUS cast
    (78) single_operand -> . MINUS cast
    (62) comparison -> . arithmetic_precedence
    (63) comparison -> . comparison LT arithmetic_precedence
    (64) comparison -> . comparison GT arithmetic_precedence
    (65) comparison -> . comparison LE arithmetic_precedence
    (66) comparison -> . comparison GE arithmetic_precedence
    (79) expression_combination -> . IDENTIFIER
    (80) expression_combination -> . NUMBER
    (81) expression_combination -> . LPAREN expression RPAREN
    (82) expression_combination -> . expression_combination LPAREN assigning RPAREN
    (83) expression_combination -> . expression_combination LPAREN assigning COMMA assigning RPAREN
    (84) expression_combination -> . expression_combination LPAREN RPAREN
    (72) arithmetic_precedence -> . multiply_division
    (73) arithmetic_precedence -> . arithmetic_precedence PLUS multiply_division
    (74) arithmetic_precedence -> . arithmetic_precedence MINUS multiply_division
    (67) multiply_division -> . cast
    (68) multiply_division -> . multiply_division TIMES cast
    (69) multiply_division -> . multiply_division DIVIDE cast
    (70) cast -> . single_operand
    (71) cast -> . LPAREN variable_detector_2 RPAREN cast

    LBRACE          shift and go to state 4
    IF              shift and go to state 19
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    DO              shift and go to state 23
    SEMICOLON       reduce using rule 85 (empty -> .)
    TIMES           shift and go to state 29
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    IDENTIFIER      shift and go to state 34
    NUMBER          shift and go to state 35
    LPAREN          shift and go to state 20

    expression_2                   shift and go to state 13
    stmnt                          shift and go to state 172
    nested_stmnt                   shift and go to state 14
    if                             shift and go to state 15
    loops                          shift and go to state 16
    empty                          shift and go to state 17
    expression                     shift and go to state 18
    assigning                      shift and go to state 24
    equal_unequal                  shift and go to state 25
    single_operand                 shift and go to state 26
    comparison                     shift and go to state 27
    expression_combination         shift and go to state 28
    cast                           shift and go to state 30
    arithmetic_precedence          shift and go to state 33
    multiply_division              shift and go to state 36

state 171

    (27) starting_brace -> LBRACE starting_brace COMMA starting_brace COMMA RBRACE .

    SEMICOLON       reduce using rule 27 (starting_brace -> LBRACE starting_brace COMMA starting_brace COMMA RBRACE .)
    COMMA           reduce using rule 27 (starting_brace -> LBRACE starting_brace COMMA starting_brace COMMA RBRACE .)
    RBRACE          reduce using rule 27 (starting_brace -> LBRACE starting_brace COMMA starting_brace COMMA RBRACE .)


state 172

    (50) loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .

    RBRACE          reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    LBRACE          reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    IF              reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    WHILE           reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    FOR             reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    DO              reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    TIMES           reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    PLUS            reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    MINUS           reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    IDENTIFIER      reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    NUMBER          reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    LPAREN          reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    SEMICOLON       reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)
    ELSE            reduce using rule 50 (loops -> FOR LPAREN expression_2 SEMICOLON expression_2 SEMICOLON expression_2 RPAREN stmnt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 135 resolved as shift
